/* BEGIN_HEADER */
#include "mbedtls/bignum.h"
#include "mbedtls/entropy.h"
#include "bignum_mod_raw.h"
#include "constant_time_internal.h"
#include "test/constant_flow.h"

/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_BIGNUM_C
 * END_DEPENDENCIES
 */

/* BEGIN_CASE */
void mpi_mod_raw_io( data_t *input, int nb_int, int nx_32_int,
                     int iendian, int iret, int oret )
{
    if( iret != 0 )
        TEST_ASSERT( oret == 0 );

    TEST_LE_S( 0, nb_int );
    size_t nb = nb_int;

    unsigned char buf[1024];
    TEST_LE_U( nb, sizeof( buf ) );

    /* nx_32_int is the number of 32 bit limbs, if we have 64 bit limbs we need
     * to halve the number of limbs to have the same size. */
    size_t nx;
    TEST_LE_S( 0, nx_32_int );
    if( sizeof( mbedtls_mpi_uint ) == 8 )
        nx = nx_32_int / 2 + nx_32_int % 2;
    else
        nx = nx_32_int;

    mbedtls_mpi_uint X[sizeof( buf ) / sizeof( mbedtls_mpi_uint )];
    TEST_LE_U( nx, sizeof( X ) / sizeof( X[0] ) );

    int endian;
    if( iendian == MBEDTLS_MPI_MOD_EXT_REP_INVALID )
        endian = MBEDTLS_MPI_MOD_EXT_REP_LE;
    else
        endian = iendian;

    mbedtls_mpi_mod_modulus m;
    mbedtls_mpi_mod_modulus_init( &m );
    mbedtls_mpi_uint init[sizeof( X ) / sizeof( X[0] )];
    memset( init, 0xFF, sizeof( init ) );
    int ret = mbedtls_mpi_mod_modulus_setup( &m, init, nx, endian,
                                             MBEDTLS_MPI_MOD_REP_MONTGOMERY );
    TEST_EQUAL( ret, 0 );

    if( iendian == MBEDTLS_MPI_MOD_EXT_REP_INVALID && iret != 0 )
        m.ext_rep = MBEDTLS_MPI_MOD_EXT_REP_INVALID;

    ret = mbedtls_mpi_mod_raw_read( X, &m, input->x, input->len );
    TEST_EQUAL( ret, iret );

    if( iret == 0 )
    {
        if( iendian == MBEDTLS_MPI_MOD_EXT_REP_INVALID && oret != 0 )
            m.ext_rep = MBEDTLS_MPI_MOD_EXT_REP_INVALID;

        ret = mbedtls_mpi_mod_raw_write( X, &m, buf, nb );
        TEST_EQUAL( ret, oret );
    }

    if( ( iret == 0 ) && ( oret == 0 ) )
    {
        if( nb > input->len )
        {
            if( endian == MBEDTLS_MPI_MOD_EXT_REP_BE )
            {
                size_t leading_zeroes = nb - input->len;
                TEST_ASSERT( memcmp( buf + nb - input->len, input->x, input->len ) == 0 );
                for( size_t i = 0; i < leading_zeroes; i++ )
                    TEST_EQUAL( buf[i], 0 );
            }
            else
            {
                TEST_ASSERT( memcmp( buf, input->x, input->len ) == 0 );
                for( size_t i = input->len; i < nb; i++ )
                    TEST_EQUAL( buf[i], 0 );
            }
        }
        else
        {
            if( endian == MBEDTLS_MPI_MOD_EXT_REP_BE )
            {
                size_t leading_zeroes = input->len - nb;
                TEST_ASSERT( memcmp( input->x + input->len - nb, buf, nb ) == 0 );
                for( size_t i = 0; i < leading_zeroes; i++ )
                    TEST_EQUAL( input->x[i], 0 );
            }
            else
            {
                TEST_ASSERT( memcmp( input->x, buf, nb ) == 0 );
                for( size_t i = nb; i < input->len; i++ )
                    TEST_EQUAL( input->x[i], 0 );
            }
        }
    }

exit:
    mbedtls_mpi_mod_modulus_free( &m );
}
/* END_CASE */
