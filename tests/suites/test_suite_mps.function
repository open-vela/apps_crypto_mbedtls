/* BEGIN_HEADER */

#include <stdlib.h>

/* TODO: How are test suites supposed to include internal headers? */
#include "../library/mps/reader.h"

/*
 * Compile-time configuration for test suite.
 */

/* Comment/Uncomment this to disable/enable the
 * testing of the various MPS layers.
 * This can be useful for time-consuming instrumentation
 * tasks such as the conversion of E-ACSL annotations
 * into runtime assertions. */
#define TEST_SUITE_MPS_READER

/* End of compile-time configuration. */

/* END_HEADER */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_single_round( int with_acc )
{
    /* This test exercises the most basic use of the MPS reader:
     * - The 'producing' layer provides a buffer
     * - The 'consuming' layer fetches it in a single go.
     * - After processing, the consuming layer commit the data
     *   and returns back to the producing layer.
     *
     * Parameters:
     * - with_acc: 0 if the reader should be initialized without accumulator.
     *             1 if the reader should be initialized with accumulator.
     *
     *             Whether the accumulator is present or not should not matter,
     *             since the consumer's request can be fulfilled from the data
     *             that the producer has provided.
     */
    unsigned char bufA[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 100, bufA, 100 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_multiple_rounds( int with_acc )
{
    /* This test exercises multiple rounds o fthe basic use of the MPS reader:
     * - The 'producing' layer provides a buffer
     * - The 'consuming' layer fetches it in a single go.
     * - After processing, the consuming layer commit the data
     *   and returns back to the producing layer.
     *
     * Parameters:
     * - with_acc: 0 if the reader should be initialized without accumulator.
     *             1 if the reader should be initialized with accumulator.
     *
     *             Whether the accumulator is present or not should not matter,
     *             since the consumer's request can be fulfilled from the data
     *             that the producer has provided.
     */

    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 100, bufA, 100 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 100, bufB, 100 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_single_round( int with_acc )
{
    /* This test exercises one round of the following:
     * - The 'producing' layer provides a buffer
     * - The 'consuming' layer fetches it in multiple calls
     *   to `mbedtls_reader_get()`, without comitting in between.
     * - After processing, the consuming layer commit the data
     *   and returns back to the producing layer.
     *
     * Parameters:
     * - with_acc: 0 if the reader should be initialized without accumulator.
     *             1 if the reader should be initialized with accumulator.
     *
     *             Whether the accumulator is present or not should not matter,
     *             since the consumer's request can be fulfilled from the data
     *             that the producer has provided.
     */

    /* Lower layer provides data that the upper layer fully consumes
     * through multiple `get` calls. */
    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 10, buf, 10 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 70, buf + 10, 70 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    ASSERT_COMPARE( tmp, tmp_len, buf + 80, 20 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_multiple_rounds( int with_acc )
{
    /* This test exercises one round of fetching a buffer in multiple chunks
     * and passing it back to the producer afterwards, followed by another
     * single-step sequence of feed-fetch-commit-reclaim.
     */
    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 10, bufA, 10 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 70, bufA + 10, 70 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    ASSERT_COMPARE( tmp, tmp_len, bufA + 80, 20 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 100, bufB, 100 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_disabled()
{
    /* This test exercises the behaviour of the MPS reader when a read requests
     * of the consumer exceeds what has been provided by the producer, and when
     * no accumulator is available in the reader.
     *
     * In this case, we expect the reader to fail.
     */

    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 50, buf, 50 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_NEED_ACCUMULATOR );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_buffer_too_small()
{
    /* This test exercises the behaviour of the MPS reader with accumulator
     * in the situation where a read requests goes beyond the bounds of the
     * current read buffer, _and_ the reader's accumulator is too small to
     * hold the requested amount of data.
     *
     * In this case, we expect the reader to fail. */

    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 50, buf, 50 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_ACCUMULATOR_TOO_SMALL );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing( int option )
{
    /* This test exercises the behaviour of the reader when the
     * accumulator is used to fufill the consumer's request.
     *
     * More detailed:
     * - The producer feeds some data.
     * - The consumer asks for more data than what's available.
     * - The reader remembers the request and goes back to
     *   producing mode, waiting for more data from the producer.
     * - The producer provides another chunk of data which is
     *   sufficient to fulfill the original read request.
     * - The consumer retries the original read request, which
     *   should now succeed.
     *
     * This test comes in multiple variants controlled by the
     * `option` parameter and documented below.
     */

    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 80, bufA, 80 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 10, bufA + 80, 10 );
    switch( option )
    {
        case 0:  /* Single uncommitted fetch at pausing */
        case 1:
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;
        default: /* Multiple uncommitted fetches at pausing */
            break;
    }
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );

    /* Consumption */
    switch( option )
    {
        case 0: /* Single fetch at pausing, re-fetch with commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 90, 10 );
            ASSERT_COMPARE( tmp + 10, 10, bufB, 10 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        case 1: /* Single fetch at pausing, re-fetch without commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 90, 10 );
            ASSERT_COMPARE( tmp + 10, 10, bufB, 10 );
            break;

        case 2: /* Multiple fetches at pausing, repeat without commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 80, 10 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 90, 10 );
            ASSERT_COMPARE( tmp + 10, 10, bufB, 10 );
            break;

        case 3: /* Multiple fetches at pausing, repeat with commit 1. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 80, 10 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 90, 10 );
            ASSERT_COMPARE( tmp + 10, 10, bufB, 10 );
            break;

        case 4: /* Multiple fetches at pausing, repeat with commit 2. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 80, 10 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 90, 10 );
            ASSERT_COMPARE( tmp + 10, 10, bufB, 10 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        case 5: /* Multiple fetches at pausing, repeat with commit 3. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 80, 10 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            ASSERT_COMPARE( tmp, 10, bufA + 90, 10 );
            ASSERT_COMPARE( tmp + 10, 10, bufB, 10 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
    }

    /* In all cases, fetch the rest of the second buffer. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 90, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 90, bufB + 10, 90 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_multiple_feeds( int option )
{
    /* This test exercises the behaviour of the MPS reader
     * in the following situation:
     * - The consumer has asked for mre than what's available, so the
     *   reader pauses and waits for further input data via
     *   `mbedtls_reader_feed()`
     * - Multiple such calls to `mbedtls_reader_feed()` are necessary
     *   to fulfill the original request, and the reader needs to do
     *   the necessary bookkeeping under the hood.
     *
     * This test comes in a few variants differing in the number and
     * size of feed calls that the producer issues while the reader is
     * accumulating the necessary data - see the comments below.
     */

    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[70];
    mbedtls_reader rd;
    mbedtls_mps_size_t fetch_len;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 80, bufA, 80 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* 20 left, ask for 70 -> 50 overhead */
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    switch( option )
    {
        case 0: /* 10 + 10 + 80 byte feed */
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, 10 ) ==
                         MBEDTLS_ERR_MPS_READER_NEED_MORE );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 10, 10 ) ==
                         MBEDTLS_ERR_MPS_READER_NEED_MORE );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 20, 80 ) == 0 );
            break;

        case 1: /* 50 x 1byte */
            for( int num_feed=0; num_feed<49; num_feed++ )
            {
                TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + num_feed, 1 ) ==
                             MBEDTLS_ERR_MPS_READER_NEED_MORE );
            }
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 49, 1 ) == 0 );
            break;

        case 2: /* 49 x 1byte + 51bytes */
            for( int num_feed=0; num_feed<49; num_feed++ )
            {
                TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + num_feed, 1 ) ==
                             MBEDTLS_ERR_MPS_READER_NEED_MORE );
            }
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 49, 51 ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 20, bufA + 80, 20 );
    ASSERT_COMPARE( tmp + 20, 50, bufB, 50 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 1000, &tmp, &fetch_len ) == 0 );
    switch( option )
    {
        case 0:
            TEST_ASSERT( fetch_len == 50 );
            break;

        case 1:
            TEST_ASSERT( fetch_len == 0 );
            break;

        case 2:
            TEST_ASSERT( fetch_len == 50 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */
