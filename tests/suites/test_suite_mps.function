/* BEGIN_HEADER */

#include <stdlib.h>

/* TODO: How are test suites supposed to include internal headers? */
#include "../library/mps/reader.h"

/*
 * Compile-time configuration for test suite.
 */

/* Comment/Uncomment this to disable/enable the
 * testing of the various MPS layers.
 * This can be useful for time-consuming instrumentation
 * tasks such as the conversion of E-ACSL annotations
 * into runtime assertions. */
#define TEST_SUITE_MPS_READER

/* End of compile-time configuration. */

/* END_HEADER */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_single_round( int with_acc )
{
    /* This test exercises the most basic use of the MPS reader:
     * - The 'producing' layer provides a buffer
     * - The 'consuming' layer fetches it in a single go.
     * - After processing, the consuming layer commit the data
     *   and returns back to the producing layer.
     *
     * Parameters:
     * - with_acc: 0 if the reader should be initialized without accumulator.
     *             1 if the reader should be initialized with accumulator.
     *
     *             Whether the accumulator is present or not should not matter,
     *             since the consumer's request can be fulfilled from the data
     *             that the producer has provided.
     */
    unsigned char bufA[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 100, bufA, 100 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_multiple_rounds( int with_acc )
{
    /* This test exercises multiple rounds o fthe basic use of the MPS reader:
     * - The 'producing' layer provides a buffer
     * - The 'consuming' layer fetches it in a single go.
     * - After processing, the consuming layer commit the data
     *   and returns back to the producing layer.
     *
     * Parameters:
     * - with_acc: 0 if the reader should be initialized without accumulator.
     *             1 if the reader should be initialized with accumulator.
     *
     *             Whether the accumulator is present or not should not matter,
     *             since the consumer's request can be fulfilled from the data
     *             that the producer has provided.
     */

    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 100, bufA, 100 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 100, bufB, 100 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_single_round( int with_acc )
{
    /* This test exercises one round of the following:
     * - The 'producing' layer provides a buffer
     * - The 'consuming' layer fetches it in multiple calls
     *   to `mbedtls_reader_get()`, without comitting in between.
     * - After processing, the consuming layer commit the data
     *   and returns back to the producing layer.
     *
     * Parameters:
     * - with_acc: 0 if the reader should be initialized without accumulator.
     *             1 if the reader should be initialized with accumulator.
     *
     *             Whether the accumulator is present or not should not matter,
     *             since the consumer's request can be fulfilled from the data
     *             that the producer has provided.
     */

    /* Lower layer provides data that the upper layer fully consumes
     * through multiple `get` calls. */
    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 10, buf, 10 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 70, buf + 10, 70 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    ASSERT_COMPARE( tmp, tmp_len, buf + 80, 20 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_multiple_rounds( int with_acc )
{
    /* This test exercises one round of fetching a buffer in multiple chunks
     * and passing it back to the producer afterwards, followed by another
     * single-step sequence of feed-fetch-commit-reclaim.
     */
    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 10, bufA, 10 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 70, bufA + 10, 70 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    ASSERT_COMPARE( tmp, tmp_len, bufA + 80, 20 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 100, bufB, 100 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_disabled()
{
    /* This test exercises the behaviour of the MPS reader when a read requests
     * of the consumer exceeds what has been provided by the producer, and when
     * no accumulator is available in the reader.
     *
     * In this case, we expect the reader to fail.
     */

    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 50, buf, 50 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_NEED_ACCUMULATOR );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_buffer_too_small()
{
    /* This test exercises the behaviour of the MPS reader with accumulator
     * in the situation where a read requests goes beyond the bounds of the
     * current read buffer, _and_ the reader's accumulator is too small to
     * hold the requested amount of data.
     *
     * In this case, we expect the reader to fail. */

    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    ASSERT_COMPARE( tmp, 50, buf, 50 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_MPS_READER_ACCUMULATOR_TOO_SMALL );
    mbedtls_reader_free( &rd );
}
/* END_CASE */
